<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    

    <script>
        // 배열 : 여려 자료Type을 저장하기 위한 자료구조
        // let arr=['str1', "str2", `str3`, null, true, false, undefined, {name:"홍길동",age: 15}];
        // console.log(arr);
        // console.log(arr[0]);
        // console.log(arr[1]);
        // console.log(arr[2]);
        // console.log(arr[3]);
        // console.log(arr[4]);
        // console.log(arr[5]);
        // console.log(arr[6]);
        // console.log(arr[7]);
        // //
        // arr[8] = 100;
        // console.log(arr);
        // arr[10] = "HELLO WORLD";
        // console.log(arr);
        // console.log(typeof arr[9], typeof arr[10]);

        //-------------------------------------------------
        //배열함수 : push, pop
        //-------------------------------------------------
        // arr.push('aaa');
        // arr.push('bbb');
        // arr.push('ccc');
        // console.log(arr); 
        // arr.pop();
        // console.log(arr); 

        //-------------------------------------------------
        //배열함수 : forEach
        //-------------------------------------------------
        // arr.forEach((item)=>{ console.log('item', item)});

        //-------------------------------------------------
        // 정렬 : 
        //-------------------------------------------------
        // let arr2=[10,55,11,24,5,44,1,22]
        // console.log(arr2);
        // 오름차순 정렬
        // arr2.sort((a,b)=>{return a-b;});
        // 내림차순 정렬
        // arr2.sort((a,b)=>{return b-a;});
        // 약식
        // arr2.sort((a,b)=>b-a);
        // console.log(arr2);

        //-------------------------------------------------
        // 필터 : 
        //-------------------------------------------------
        // let arr3=[11, 'str1', 22, "str2", 33, `str3`, 10.5, null, true, false, undefined, 101, {name:"홍길동",age: 15}];

        // let result = arr3.filter(() => {return typeof item=="number"});
        // console.log(result);
        
        // let result2 = arr3.filter(() => {return typeof item=="string"});
        // console.log(result);

        //-------------------------------------------------
        // 누산 : arr.reduce(() =>, 누산변수 초기값)
        //-------------------------------------------------
        // const sum = arr3.filter((item)=>{return typeof item=="number"})     //숫자값만 필터
        //                 .reduce((sum,item)=>{return sum+item;},0)           // 누적합 구하기
        // console.log(sum);

        // //----------------------------------
        // // 배열object 처리 [{},{},{},{}...]
        // //----------------------------------
        // let arr_5 = [
        //     {pid:"1",pname:"모니터",price:100,amount:50},
        //     {pid:"2",pname:"노트북",price:200,amount:15},
        //     {pid:"3",pname:"냉장고",price:250,amount:30},
        //     {pid:"4",pname:"데스크탑",price:70,amount:19},
        //     {pid:"5",pname:"가습기",price:10,amount:200},
        // ];
        // // console.log(arr_5);
        // arr_5.forEach((item)=>{console.log(item);})
        // 처리하려는 값이 1개이면 괄호, 중괄호 생략 가능
        // arr_5.forEach(item=>console.log(item))
        // arr_5.forEach((item,index)=>{console.log(index,item);})
        // arr_5.forEach((item)=>{console.log(item["price"]);})
        
        // 각 item의 가격이 100이상인 object만 필터링
        // const filter_01 = arr_5.filter((item)=>{return item["price"]>=100;})
        // const filter_01 = arr_5.filter(item=> item["price"]>=100)
        // const filter_01 = arr_5.filter(item=> item.price>=100)
        // console.log(filter_01);

        // 각 아이템 수량이 30개 이하인 object만 필터링
        // const filter_02 = arr_5.filter(item=> item.amount<=30)
        // console.log(filter_02);

        // // 각 아이템 가격이 100만원 이상인 item의 가격 총합(누적)을 구하세요
        // const sum = arr_5.filter(item=> item.price>=100).reduce((s, item) => s + (item.price*item.amount), 0)
        // console.log('100만원 이상인 item의 price 누적합', sum);

        // 재구성 배열.map(()=>{})
        let arr_6 = [
            {pid:"1",pname:"모니터",price:100,amount:50},
            {pid:"2",pname:"노트북",price:200,amount:15},
            {pid:"3",pname:"냉장고",price:250,amount:30},
            {pid:"4",pname:"데스크탑",price:70,amount:19},
            {pid:"5",pname:"가습기",price:10,amount:200},
        ];
        
        // 스프레드 연산자(...)
        // let maped_01 = arr_6.map((item)=>{
        //     item={...item,"total_price":item.price*item.amount};
        //     console.log(item);
        //     return item;
        // })
        // console.log(maped_01);

        // 수량이 30이상인 요소만 필터링해서 / price가 낮은값 우선 오름차순 / price*amount 항목 추가
        // let zzz = arr_6.
        //     filter(item=> item.amount >= 30)
        //     .sort((a,b)=> a.price - b.price)
        //     .map(item => item={...item,"total":item.price*item.amount}
        //     );
        
        // console.log(zzz);

        let employees = [
            { id: 1, name: "김철수", age: 35, department: "개발", salary: 6000, years: 10 },
            { id: 2, name: "이영희", age: 28, department: "디자인", salary: 5000, years: 5 },
            { id: 3, name: "박지성", age: 40, department: "마케팅", salary: 7000, years: 15 },
            { id: 4, name: "손흥민", age: 30, department: "개발", salary: 6500, years: 7 },
            { id: 5, name: "정우성", age: 45, department: "경영", salary: 9000, years: 20 },
            { id: 6, name: "한지민", age: 29, department: "디자인", salary: 5200, years: 6 },
            { id: 7, name: "강호동", age: 50, department: "경영", salary: 8500, years: 25 },
            { id: 8, name: "유재석", age: 42, department: "마케팅", salary: 7500, years: 18 },
            { id: 9, name: "송중기", age: 32, department: "개발", salary: 6200, years: 8 },
            { id: 10, name: "수지", age: 26, department: "디자인", salary: 4800, years: 3 }
        ];

        //연봉이(salary) 6000이상이면서 근속연수(years)가 7년이상인(item.salary>=6000 && item.years>=7) 직원만 필터링해서 배열로 저장 확인
        let asd = employees
        .filter(item => item.salary >= 6000 && item.years >= 7)
        // console.log(asd);

        // 모든 직원의 연봉(salary) 기준으로 내림차순 정렬한 배열 새로 만들기
        let qwe = employees
        .sort((a,b) => b.salary - a.salary)
        // console.log(qwe);

        // 모든 직원의 연봉(salary) 에 근속연수*100 만큼의 보너스를 추가하여 total_salary필드를 추가한 배열을 반환
        let ewq = employees
        .map(item => item={...item, "total_salary":item.salary + (item.years*100)})
        // console.log(ewq);

        // department(부서) 별로 직원들의 연봉총합을 구하세요
        let dsa = employees
        .reduce((sum, item) => {
            // console.log(item);
            sum[item.department]=sum[item.department]==undefined?item.salary:sum[item.department]+item.salary;
            // console.log(sum);
            return sum;

        }, {});
        // console.log(dsa);

        // 연봉(salary)가 가장높은 직원을 찾아 객체하나만 반환(mdn문서에서 find를 찾아보세요 - !)
         const max_item = employees.sort((a,b)=>{return b.salary-a.salary;})[0];
         console.log(max_item);

         // 최대값 구하기
         const max_item2 = employees.find((item) => {return item.salary==max_item.salary;})
         console.log(max_item2);
        </script>
</body>
</html>
